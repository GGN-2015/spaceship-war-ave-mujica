<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç¥¥å­ğŸ˜å¤§æˆ˜</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            background-color: #333;
            font-family: Arial, sans-serif;
            color: white;
            min-height: 100vh;
            box-sizing: border-box;
            touch-action: none;
        }
        
        #gameCanvas {
            border: 2px solid #444;
            background-color: #000;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            height: auto;
            margin-bottom: 10px; /* åº•éƒ¨ç•™å‡ºç©ºé—´ */
        }
        
        #score {
            font-size: 20px;
            margin-bottom: 5px;
        }
        
        #stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 480px;
            margin-bottom: 5px;
            padding: 0 10px;
            box-sizing: border-box;
        }
        
        .stat {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 14px;
        }
        
        #controls {
            color: #aaa;
            margin-top: 10px;
            text-align: center;
            font-size: 12px;
            line-height: 1.4;
            display: none;
        }
        
        #gameOver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 36px;
            display: none;
            text-shadow: 2px 2px 4px #000;
            z-index: 100;
        }
        
        #restartBtn {
            display: none;
            position: fixed;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            z-index: 100;
        }
        
        #gameTime {
            position: fixed;
            top: 5px;
            right: 10px;
            color: white;
            font-size: 14px;
        }
        
        #waveInfo {
            position: fixed;
            top: 25px;
            right: 10px;
            color: #f39c12;
            font-size: 14px;
        }
        
        #lifeContainer {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .life-heart {
            width: 16px;
            height: 16px;
            margin-right: 4px;
            color: #e74c3c;
            font-size: 16px;
        }
        
        #bossWarning {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #c0392b;
            font-size: 28px;
            text-shadow: 0 0 10px #ff0000;
            display: none;
            z-index: 100;
        }
        
        #bossInfo {
            position: fixed;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: #f39c12;
            font-size: 14px;
            display: none;
            text-align: center;
            width: 90%;
        }
        
        #waveProgress {
            width: 100%;
            max-width: 480px;
            height: 4px;
            background-color: #555;
            margin-bottom: 5px;
        }
        
        #waveProgressBar {
            height: 100%;
            width: 0%;
            background-color: #f39c12;
            transition: width 0.5s;
        }

        @media (max-width: 480px) {
            body {
                padding: 2px;
            }
            
            #gameCanvas {
                width: 100%;
                height: auto;
                margin-top: -10px; /* å‡å°‘é¡¶éƒ¨ç©ºé—´ */
            }
            
            #controls {
                display: none;
            }
            
            .stat {
                font-size: 12px;
                padding: 2px 6px;
            }
            
            #score {
                font-size: 16px;
                margin-top: 2px;
            }
            
            #gameTime, #waveInfo {
                font-size: 12px;
            }
            
            #bossWarning {
                font-size: 24px;
            }
            
            #bossInfo {
                font-size: 12px;
                bottom: 65px; /* é¿å…ä¸åº•éƒ¨ç©ºé—´é‡å  */
            }

            #stats, #waveProgress {
                margin-top: -5px;
            }
        }
    </style>
</head>
<body>
    <div id="score">å¾—åˆ†: 0</div>
    <div id="lifeContainer">ç”Ÿå‘½: <span id="lifeDisplay"></span></div>
    <div id="stats">
        <div class="stat">æ”»å‡»: <span id="attack">1</span></div>
        <div class="stat">æ”»é€Ÿ: <span id="fireRate">1</span></div>
        <div class="stat">å¤šé‡: <span id="multiShot">1</span></div>
    </div>
    <div id="waveProgress">
        <div id="waveProgressBar"></div>
    </div>
    <canvas id="gameCanvas" width="480" height="700"></canvas>
    <div id="gameTime">æ¸¸æˆæ—¶é—´: 00:00</div>
    <div id="waveInfo">ç¬¬1æ³¢</div>
    <div id="bossWarning">è­¦å‘Š: ç‰¹æ®ŠBOSSæ¥è¢­!</div>
    <div id="bossInfo"></div>
    <div id="gameOver">æ¸¸æˆç»“æŸ</div>
    <button id="restartBtn">é‡æ–°å¼€å§‹</button>
    <div id="controls">
        æ§åˆ¶è¯´æ˜:<br>
        è§¦æ‘¸å±å¹•ç§»åŠ¨é£æœº<br>
        (è‡ªåŠ¨å°„å‡»å·²å¯ç”¨)
    </div>

    <script>
        // è·å–DOMå…ƒç´ 
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const attackElement = document.getElementById('attack');
        const fireRateElement = document.getElementById('fireRate');
        const multiShotElement = document.getElementById('multiShot');
        const gameOverElement = document.getElementById('gameOver');
        const restartBtn = document.getElementById('restartBtn');
        const gameTimeElement = document.getElementById('gameTime');
        const waveInfoElement = document.getElementById('waveInfo');
        const lifeDisplayElement = document.getElementById('lifeDisplay');
        const bossWarningElement = document.getElementById('bossWarning');
        const bossInfoElement = document.getElementById('bossInfo');
        const waveProgressBar = document.getElementById('waveProgressBar');
        
        // æ¸¸æˆçŠ¶æ€
        let score = 0;
        let gameStarted = true;
        let lastBulletTime = 0;
        let enemyGenerationInterval;
        let gameLevel = 1;
        let gameTime = 0;
        let waveNumber = 1;
        let bossSpawned = 0;
        let currentBossType = null;
        let gameTimeInterval;
        let waveInterval;
        let enemiesDefeated = 0;
        let enemiesRequiredForBoss = 12;
        let invincibleTime = 0;
        let enemyLimit = 6;
        let isCreatingBoss = false;
        
        // é¢œè‰²å®šä¹‰
        const colors = {
            player: '#3498db',  // è“è‰²
            playerDamaged: '#e74c3c', // å—ä¼¤æ—¶çš„é¢œè‰²
            bullet: '#f1c40f',  // é»„è‰²
            background: '#000', // é»‘è‰²
            powerUpAttack: '#e74c3c',    // çº¢è‰²
            powerUpFireRate: '#2ecc71',  // ç»¿è‰²
            powerUpMultiShot: '#9b59b6',  // ç´«è‰²
            powerUpHealth: '#e67e22'     // æ©™è‰²
        };
        
        // Bossç±»å‹å®šä¹‰
        const bossTypes = [
            {
                name: "æ ‡å‡†ä½œæˆ˜å‹",
                shape: "boss",
                color: '#c0392b',  // æ·±çº¢è‰²
                width: 120,
                height: 120,
                baseSpeed: 1,
                baseHp: 50,  // å¢åŠ åˆå§‹è¡€é‡
                score: 3000,
                dropRate: 1.0,
                shootRate: 0.02,
                bulletSize: 14,
                movementPattern: "boss",
                special: "multiAttack",
                phaseThresholds: [0.7, 0.4],
                description: "æ ‡å‡†ä½œæˆ˜å‹Boss - å¤šé‡æ”»å‡»æ¨¡å¼",
                difficulty: 1,  // éš¾åº¦ç­‰çº§
                resistance: 0.2  // ä¼¤å®³æŠ—æ€§
            },
            {
                name: "æŠ¤ç›¾å†ç”Ÿå‹",
                shape: "shieldBoss",
                color: '#2980b9',  // æ·±è“è‰²
                width: 130,
                height: 130,
                baseSpeed: 0.8,
                baseHp: 60,  // å¢åŠ è¡€é‡
                score: 3500,
                dropRate: 1.0,
                shootRate: 0.015,
                bulletSize: 14,
                movementPattern: "shieldBoss",
                special: "regenerateShield",
                shieldHp: 25,  // å¢åŠ æŠ¤ç›¾
                shieldRegenRate: 0.05,
                phaseThresholds: [0.5],
                description: "æŠ¤ç›¾å†ç”Ÿå‹Boss - å®šæœŸæ¢å¤æŠ¤ç›¾",
                difficulty: 2,
                resistance: 0.25
            },
            {
                name: "åˆ†èº«æˆ˜æœ¯å‹",
                shape: "cloneBoss",
                color: '#16a085',  // é’è‰²
                width: 100,
                height: 100,
                baseSpeed: 1.2,
                baseHp: 55,  // å¢åŠ è¡€é‡
                score: 4000,
                dropRate: 1.0,
                shootRate: 0.02,
                bulletSize: 12,
                movementPattern: "cloneBoss",
                special: "createClones",
                cloneCount: 1,
                cloneHp: 15,  // å¢åŠ åˆ†èº«è¡€é‡
                phaseThresholds: [0.5],
                description: "åˆ†èº«æˆ˜æœ¯å‹Boss - åˆ›é€ åˆ†èº«ååŒä½œæˆ˜",
                difficulty: 3,
                resistance: 0.3
            },
            {
                name: "å¼¹å¹•ç‹‚çƒ­å‹",
                shape: "bulletHellBoss",
                color: '#8e44ad',  // ç´«è‰²
                width: 110,
                height: 110,
                baseSpeed: 0.9,
                baseHp: 65,  // å¢åŠ è¡€é‡
                score: 4500,
                dropRate: 1.0,
                shootRate: 0.03,
                bulletSize: 10,
                movementPattern: "bulletHellBoss",
                special: "bulletHell",
                bulletPatterns: ["spiral", "wave"],
                phaseThresholds: [0.5],
                description: "å¼¹å¹•ç‹‚çƒ­å‹Boss - å¤æ‚å¼¹å¹•æ”»å‡»æ¨¡å¼",
                difficulty: 4,
                resistance: 0.35
            },
            {
                name: "æ¿€å…‰ç§‘æŠ€å‹",
                shape: "laserBoss",
                color: '#d35400',  // æ©™è‰²
                width: 140,
                height: 110,
                baseSpeed: 0.7,
                baseHp: 70,  // å¢åŠ è¡€é‡
                score: 5000,
                dropRate: 1.0,
                shootRate: 0.015,
                bulletSize: 14,
                movementPattern: "laserBoss",
                special: "laserAttack",
                laserWidth: 25,
                laserDamage: 1,
                laserCooldown: 7000,
                phaseThresholds: [0.5],
                description: "æ¿€å…‰ç§‘æŠ€å‹Boss - å‘å°„å¼ºåŠ›æ¿€å…‰æŸ",
                difficulty: 5,
                resistance: 0.4
            },
            {
                name: "è¶…çº§ç»Ÿåˆå‹",
                shape: "superBoss",
                color: '#7f8c8d',  // é‡‘å±ç°è‰²
                width: 160,
                height: 160,
                baseSpeed: 0.6,
                baseHp: 150,  // å¢åŠ è¡€é‡
                score: 10000,
                dropRate: 1.0,
                shootRate: 0.04,
                bulletSize: 16,
                movementPattern: "superBoss",
                special: "combinedAttack",
                phaseThresholds: [0.7, 0.4],
                attackPatterns: ["shield", "clone", "bulletHell"],
                description: "è¶…çº§ç»Ÿåˆå‹Boss - ç»¼åˆå¤šç§æ”»å‡»æ¨¡å¼",
                difficulty: 6,
                resistance: 0.5  // é«˜ä¼¤å®³æŠ—æ€§
            }
        ];
        
        // æ™®é€šæ•Œæœºç±»å‹
        const enemyTypes = [
            {
                name: "å°å‹æˆ˜æœº",
                shape: "triangle",
                color: '#e74c3c',  // çº¢è‰²
                width: 40,
                height: 40,
                baseSpeed: 2.5,
                baseHp: 2,  // å¢åŠ è¡€é‡
                score: 100,
                dropRate: 0.05,  // é™ä½æ‰è½ç‡
                shootRate: 0,
                bulletSize: 8,
                movementPattern: "linear",
                special: null,
                difficulty: 1,
                resistance: 0
            },
            {
                name: "ä¸­å‹æˆ˜æœº",
                shape: "rectangle",
                color: '#e67e22',  // æ©™è‰²
                width: 60,
                height: 60,
                baseSpeed: 1.8,
                baseHp: 3,  // å¢åŠ è¡€é‡
                score: 200,
                dropRate: 0.05,
                shootRate: 0.003,
                bulletSize: 10,
                movementPattern: "zigzag",
                special: null,
                difficulty: 2,
                resistance: 0.05
            },
            {
                name: "å¤§å‹æˆ˜æœº",
                shape: "diamond",
                color: '#f39c12',  // é»„è‰²
                width: 80,
                height: 80,
                baseSpeed: 1.3,
                baseHp: 5,  // å¢åŠ è¡€é‡
                score: 300,
                dropRate: 0.05,
                shootRate: 0.005,
                bulletSize: 12,
                movementPattern: "sine",
                special: null,
                difficulty: 3,
                resistance: 0.1
            },
            {
                name: "è¿½è¸ªè€…",
                shape: "circle",
                color: '#9b59b6',  // ç´«è‰²
                width: 45,
                height: 45,
                baseSpeed: 2.0,
                baseHp: 3,  // å¢åŠ è¡€é‡
                score: 250,
                dropRate: 0.05,
                shootRate: 0,
                bulletSize: 8,
                movementPattern: "tracking",
                special: "tracking",
                difficulty: 4,
                resistance: 0.15
            },
            {
                name: "åˆ†è£‚è€…",
                shape: "hexagon",
                color: '#16a085',  // é’è‰²
                width: 65,
                height: 65,
                baseSpeed: 1.5,
                baseHp: 4,  // å¢åŠ è¡€é‡
                score: 400,
                dropRate: 0.05,
                shootRate: 0.004,
                bulletSize: 11,
                movementPattern: "bounce",
                special: "split",
                difficulty: 5,
                resistance: 0.2
            },
            {
                name: "æŠ¤ç›¾æˆ˜æœº",
                shape: "shield",
                color: '#2980b9',  // æ·±è“è‰²
                width: 55,
                height: 55,
                baseSpeed: 1.8,
                baseHp: 3,  // å¢åŠ è¡€é‡
                score: 350,
                dropRate: 0.05,
                shootRate: 0.004,
                bulletSize: 10,
                movementPattern: "circle",
                special: "shield",
                shieldHp: 2,
                difficulty: 6,
                resistance: 0.25
            },
            {
                name: "ç²¾è‹±æˆ˜æœº",
                shape: "star",
                color: '#8e44ad',  // æ·±ç´«è‰²
                width: 70,
                height: 70,
                baseSpeed: 1.6,
                baseHp: 7,  // å¢åŠ è¡€é‡
                score: 500,
                dropRate: 0.05,
                shootRate: 0.008,
                bulletSize: 14,
                movementPattern: "complex",
                special: "burst",
                difficulty: 7,
                resistance: 0.3
            }
        ];
        
        // ç©å®¶å¯¹è±¡
        const player = {
            x: canvas.width / 2 - 37,
            y: canvas.height - 105,
            width: 75,
            height: 75,
            speedX: 5,
            speedY: 4,  // ä¸Šä¸‹ç§»åŠ¨é€Ÿåº¦
            isAlive: true,
            tilt: 0,
            maxLives: 5,
            lives: 3,
            invincible: false,
            invincibleTime: 0,
            blinkTime: 0,
            stats: {
                attack: 1,      // åŸºç¡€æ”»å‡»åŠ›
                fireRate: 1,    // åŸºç¡€æ”»å‡»é€Ÿåº¦
                multiShot: 1    // åŸºç¡€å¤šé‡å°„å‡»
            },
            maxStats: {
                attack: 8,      // æœ€å¤§æ”»å‡»åŠ›
                fireRate: 8,    // æœ€å¤§æ”»å‡»é€Ÿåº¦
                multiShot: 3    // æœ€å¤§å¤šé‡å°„å‡»
            },
            autoFire: true,     // è‡ªåŠ¨å°„å‡»
            autoFireInterval: null,
            movementBounds: {   // ç§»åŠ¨è¾¹ç•Œ
                minY: 350,      // ç©å®¶å¯ä»¥ç§»åŠ¨åˆ°çš„æœ€é«˜ä½ç½®
                maxY: 650       // ç©å®¶å¯ä»¥ç§»åŠ¨åˆ°çš„æœ€ä½ä½ç½®
            }
        };
        
        // æ¸¸æˆå¯¹è±¡æ•°ç»„
        let bullets = [];
        let enemyBullets = [];
        let enemies = [];
        let powerUps = [];
        let particles = [];
        let lasers = [];
        let clones = []; // ä¸“é—¨å­˜å‚¨å…‹éš†ä½“çš„æ•°ç»„
        let splitEnemies = []; // ä¸“é—¨å­˜å‚¨åˆ†è£‚ä½“çš„æ•°ç»„
        
        // é”®ç›˜çŠ¶æ€
        const keys = {
            left: false,
            right: false,
            up: false,
            down: false
        };
        
        // é”®ç›˜äº‹ä»¶ç›‘å¬
        window.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowLeft' || e.key === 'Left' || e.key === 'a' || e.key === 'A') keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'Right' || e.key === 'd' || e.key === 'D') keys.right = true;
            if (e.key === 'ArrowUp' || e.key === 'Up' || e.key === 'w' || e.key === 'W') keys.up = true;
            if (e.key === 'ArrowDown' || e.key === 'Down' || e.key === 's' || e.key === 'S') keys.down = true;
            
            if(['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', function(e) {
            if (e.key === 'ArrowLeft' || e.key === 'Left' || e.key === 'a' || e.key === 'A') keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'Right' || e.key === 'd' || e.key === 'D') keys.right = false;
            if (e.key === 'ArrowUp' || e.key === 'Up' || e.key === 'w' || e.key === 'W') keys.up = false;
            if (e.key === 'ArrowDown' || e.key === 'Down' || e.key === 's' || e.key === 'S') keys.down = false;
        });
        
        // é‡æ–°å¼€å§‹æŒ‰é’®äº‹ä»¶
        restartBtn.addEventListener('click', function() {
            resetGame();
            window.location.reload();
        });
        
        // æ›´æ–°ç”Ÿå‘½æ˜¾ç¤º
        function updateLifeDisplay() {
            lifeDisplayElement.innerHTML = '';
            for (let i = 0; i < player.lives; i++) {
                lifeDisplayElement.innerHTML += 'â¤ï¸';
            }
            for (let i = player.lives; i < player.maxLives; i++) {
                lifeDisplayElement.innerHTML += 'ğŸ–¤';
            }
        }

        // ç»˜åˆ¶å¿ƒå½¢å­å¼¹çš„å‡½æ•°
        function drawHeartBullet(bullet) {
            ctx.fillStyle = bullet.color;
            ctx.beginPath();
            const x = bullet.x + bullet.width / 2;
            const y = bullet.y + bullet.height / 2;
            const size = bullet.width / 2;
            ctx.moveTo(x, y);
            ctx.bezierCurveTo(
                x + size / 2,
                y - size,
                x + size * 2,
                y + size / 3,
                x,
                y + size
            );
            ctx.bezierCurveTo(
                x - size * 2,
                y + size / 3,
                x - size / 2,
                y - size,
                x,
                y
            );
            ctx.fill();
        }
        
        // æ›´æ–°æ³¢æ¬¡è¿›åº¦æ¡
        function updateWaveProgress() {
            if(bossSpawned == 0){
                const progress = Math.min(100, (enemiesDefeated / enemiesRequiredForBoss) * 100);
                waveProgressBar.style.width = progress + '%';
            }
        }
        
        // è®¡ç®—æ³¢æ¬¡å€ç‡çš„å‡½æ•°
        function calculateWaveMultiplier(wave) {
            // ä½¿ç”¨å¯¹æ•°å‡½æ•°ä½¿å¾—å±æ€§å¢é•¿æ›´å¹³ç¼“
            // ç¬¬1æ³¢ä¸º1å€ï¼Œç¬¬10æ³¢çº¦ä¸º2å€ï¼Œç¬¬20æ³¢çº¦ä¸º2.5å€
            return 1 + Math.log2(wave) * 0.5;
        }
        
        // åˆ›å»ºæ•Œæœº
        function createEnemy(typeIndex = null) {
            if (!player.isAlive) return;
            
            // å¦‚æœæ•Œäººæ•°é‡è¾¾åˆ°ä¸Šé™ï¼Œä¸å†ç”Ÿæˆ
            if (enemies.length >= enemyLimit) return;
            
            // æ ¹æ®æ³¢æ•°è°ƒæ•´æ•Œæœºå‡ºç°æ¦‚ç‡
            const availableTypes = [];
            for (let i = 0; i < enemyTypes.length; i++) {
                if (enemyTypes[i].difficulty <= Math.min(waveNumber, 7)) {
                    availableTypes.push(i);
                }
            }
            
            if (availableTypes.length === 0) {
                typeIndex = 0;
            } else {
                typeIndex = typeIndex || availableTypes[Math.floor(Math.random() * availableTypes.length)];
            }
            
            const type = enemyTypes[typeIndex];
            
            // ä½¿ç”¨calculateWaveMultiplierè®¡ç®—å±æ€§
            const waveMultiplier = calculateWaveMultiplier(waveNumber);
            const hp = Math.ceil(type.baseHp * waveMultiplier);
            const speed = type.baseSpeed * (1 + Math.log10(Math.max(1, waveNumber - 1)) * 0.15);
            
            // åˆ›å»ºæ•Œæœºå¯¹è±¡
            const enemy = {
                x: Math.random() * (canvas.width - type.width),
                y: -type.height,
                width: type.width,
                height: type.height,
                speed: speed,
                color: type.color,
                shape: type.shape,
                hp: hp,
                maxHp: hp,
                score: type.score,
                dropRate: type.dropRate,
                shootRate: type.shootRate * waveMultiplier,
                bulletSize: type.bulletSize,
                type: typeIndex,
                special: type.special,
                movementPattern: type.movementPattern,
                movementTime: 0,
                amplitude: Math.random() * 50 + 30,  // ç§»åŠ¨æŒ¯å¹…
                frequency: Math.random() * 0.02 + 0.01,  // ç§»åŠ¨é¢‘ç‡
                direction: Math.random() > 0.5 ? 1 : -1,  // ç§»åŠ¨æ–¹å‘
                lastShot: 0,
                initialX: Math.random() * (canvas.width - type.width),
                isBoss: false,
                resistance: type.resistance || 0,  // ä¼¤å®³æŠ—æ€§
                hasSplit: false  // æ·»åŠ åˆ†è£‚æ ‡è®°
            };
            
            // ç‰¹æ®Šæ•Œæœºå±æ€§
            if (type.special === "shield") {
                enemy.shield = type.shieldHp * waveMultiplier;
                enemy.maxShield = enemy.shield;
            }
            
            enemies.push(enemy);
        }
        
        // åˆ›å»ºBoss
        function createBoss() {
            // æ£€æŸ¥æ˜¯å¦å·²æœ‰Bossæˆ–æ­£åœ¨åˆ›å»ºBoss
            if (bossSpawned > 0 || isCreatingBoss) return;
            
            isCreatingBoss = true; // è®¾ç½®æ ‡å¿—
            
            // æ ¹æ®å½“å‰æ³¢æ¬¡é€‰æ‹©åˆé€‚çš„Boss
            let availableBosses = [];
            for (let i = 0; i < bossTypes.length; i++) {
                if (bossTypes[i].difficulty <= Math.min(Math.ceil(waveNumber / 2), 6)) {
                    availableBosses.push(i);
                }
            }
            
            // å¦‚æœæ²¡æœ‰åˆé€‚çš„Bossï¼Œä½¿ç”¨æœ€åŸºæœ¬çš„Boss
            let bossTypeIndex = 0;
            if (availableBosses.length > 0) {
                bossTypeIndex = availableBosses[Math.floor(Math.random() * availableBosses.length)];
            }
            
            // è¶…çº§Bossåªåœ¨é«˜æ³¢æ¬¡å‡ºç°
            if (bossTypeIndex === 5 && waveNumber < 10) {
                bossTypeIndex = Math.floor(Math.random() * 5);
            }
            
            const bossType = bossTypes[bossTypeIndex]
            currentBossType = bossTypeIndex;
            
            // æ˜¾ç¤ºBossè­¦å‘Š
            bossWarningElement.textContent = `è­¦å‘Š: ${bossType.name}BOSSæ¥è¢­!`;
            bossWarningElement.style.display = 'block';
            
            // æ˜¾ç¤ºBossä¿¡æ¯
            bossInfoElement.textContent = bossType.description;
            bossInfoElement.style.display = 'block';
            
            setTimeout(() => {
                bossWarningElement.style.display = 'none';
                bossInfoElement.style.display = 'none';
                
                // ä½¿ç”¨calculateWaveMultiplierè®¡ç®—Bosså±æ€§
                const waveMultiplier = calculateWaveMultiplier(waveNumber);
                const hp = Math.ceil(bossType.baseHp * waveMultiplier);
                
                // åˆ›å»ºBosså¯¹è±¡
                const boss = {
                    x: canvas.width / 2 - bossType.width / 2,
                    y: -bossType.height,
                    width: bossType.width,
                    height: bossType.height,
                    speed: bossType.baseSpeed,
                    color: bossType.color,
                    shape: bossType.shape,
                    hp: hp,
                    maxHp: hp,
                    score: bossType.score,
                    dropRate: bossType.dropRate,
                    shootRate: bossType.shootRate,
                    bulletSize: bossType.bulletSize,
                    type: bossTypeIndex,
                    special: bossType.special,
                    movementPattern: bossType.movementPattern,
                    movementTime: 0,
                    lastShot: 0,
                    phaseThresholds: bossType.phaseThresholds,
                    currentPhase: 0,
                    isBoss: true,
                    bossType: bossTypeIndex,
                    resistance: bossType.resistance || 0  // ä¼¤å®³æŠ—æ€§
                };
                
                // ç‰¹æ®ŠBosså±æ€§
                if (bossType.special === "regenerateShield") {
                    boss.shield = bossType.shieldHp * waveMultiplier;
                    boss.maxShield = boss.shield;
                    boss.shieldRegenRate = bossType.shieldRegenRate;
                    boss.lastShieldRegen = Date.now();
                } else if (bossType.special === "createClones") {
                    boss.cloneCount = bossType.cloneCount;
                    boss.cloneHp = bossType.cloneHp * waveMultiplier;
                    boss.lastCloneCreation = null; // åˆå§‹åŒ–ä¸ºnull
                    boss.clonesCreated = 0; // æ·»åŠ å…‹éš†è®¡æ•°å™¨
                    console.log("å…‹éš†Bosså·²åˆ›å»º - é¢„æœŸå…‹éš†æ•°é‡:", boss.cloneCount);
                } else if (bossType.special === "bulletHell") {
                    boss.bulletPatterns = bossType.bulletPatterns;
                    boss.currentPattern = 0;
                } else if (bossType.special === "laserAttack") {
                    boss.laserWidth = bossType.laserWidth;
                    boss.laserDamage = bossType.laserDamage;
                    boss.laserCooldown = bossType.laserCooldown;
                    boss.lastLaserAttack = Date.now();
                } else if (bossType.special === "combinedAttack") {
                    boss.attackPatterns = bossType.attackPatterns;
                    boss.shield = 30 * waveMultiplier;
                    boss.maxShield = 30 * waveMultiplier;
                    boss.shieldRegenRate = 0.03;
                    boss.lastShieldRegen = Date.now();
                    boss.cloneCount = 1;
                    boss.cloneHp = 10 * waveMultiplier;
                    boss.lastCloneCreation = Date.now();
                    boss.laserWidth = 30;
                    boss.laserDamage = 1;
                    boss.laserCooldown = 10000;
                    boss.lastLaserAttack = Date.now();
                }
                
                enemies.push(boss);
                bossSpawned++;  // å¢åŠ Bossè®¡æ•°
                isCreatingBoss = false; // é‡ç½®æ ‡å¿—
            }, 3000);
        }
        
        // åˆ›å»ºBosså…‹éš†ä½“
        function createBossClone(boss) {
            const cloneSize = boss.width * 0.8;
            const angle = Math.random() * Math.PI * 2;
            const distance = boss.width * 2;
            
            const centerX = boss.x + boss.width/2;
            const centerY = boss.y + boss.height/2;
            
            let cloneX = centerX + Math.cos(angle) * distance - cloneSize/2;
            let cloneY = centerY + Math.sin(angle) * distance - cloneSize/2;
            
            // è¾¹ç•Œæ£€æŸ¥
            cloneX = Math.max(cloneSize, Math.min(canvas.width - cloneSize * 2, cloneX));
            cloneY = Math.max(cloneSize, Math.min(canvas.height/2 - cloneSize, cloneY));
            
            const clone = {
                x: cloneX,
                y: cloneY,
                width: cloneSize,
                height: cloneSize,
                speed: boss.speed * 1.2,
                color: '#1abc9c',
                shape: "cloneBoss",
                hp: boss.cloneHp,
                maxHp: boss.cloneHp,
                score: Math.floor(boss.score * 0.2),
                dropRate: 0,
                shootRate: boss.shootRate * 0.5,
                bulletSize: boss.bulletSize * 0.7,
                special: null,
                movementPattern: "clone",
                movementTime: Math.random() * Math.PI * 2,
                lastShot: 0,
                isBoss: false,
                isClone: true,
                parentBoss: boss,
                resistance: boss.resistance * 0.5,
                orbitRadius: distance,
                baseOrbitRadius: distance,  // åŸºç¡€è½¨é“åŠå¾„
                orbitSpeed: 1.5 + Math.random(),  // éšæœºçš„åŸºç¡€æ—‹è½¬é€Ÿåº¦
                initialAngle: angle,
                radiusPhase: Math.random() * Math.PI * 2,  // åŠå¾„å˜åŒ–çš„ç›¸ä½
                radiusSpeed: 0.5 + Math.random() * 0.5,    // åŠå¾„å˜åŒ–çš„é€Ÿåº¦
                verticalPhase: Math.random() * Math.PI * 2, // å‚ç›´è¿åŠ¨çš„ç›¸ä½
                directionChangeTime: 0,  // æ–¹å‘æ”¹å˜è®¡æ—¶å™¨
                currentDirection: 1,     // å½“å‰è¿åŠ¨æ–¹å‘
                lastDirectionChange: Date.now()  // ä¸Šæ¬¡æ”¹å˜æ–¹å‘çš„æ—¶é—´
            };
            
            clones.push(clone);
            
            createExplosion(clone.x + clone.width/2, clone.y + clone.height/2, clone.color, 30);
        }
        
        // åˆ›å»ºèƒ½åŠ›é“å…·
        function createPowerUp(x, y, type = null) {
            // å¦‚æœç©å®¶å·²è¾¾åˆ°æŸä¸ªèƒ½åŠ›çš„ä¸Šé™ï¼Œä¸å†æ‰è½è¯¥ç±»å‹é“å…·
            let availableTypes = [];
            if (player.stats.attack < player.maxStats.attack) availableTypes.push('attack');
            if (player.stats.fireRate < player.maxStats.fireRate) availableTypes.push('fireRate');
            if (player.stats.multiShot < player.maxStats.multiShot) availableTypes.push('multiShot');
            if (player.lives < player.maxLives) availableTypes.push('health');
            
            // å¦‚æœæ‰€æœ‰èƒ½åŠ›éƒ½è¾¾åˆ°ä¸Šé™ï¼Œåªæ‰è½ç”Ÿå‘½é“å…·
            if (availableTypes.length === 0 && player.lives < player.maxLives) {
                availableTypes.push('health');
            } else if (availableTypes.length === 0) {
                // å¦‚æœç”Ÿå‘½ä¹Ÿæ»¡äº†ï¼Œå°±ä¸æ‰è½é“å…·
                return;
            }
            
            const randomType = type || availableTypes[Math.floor(Math.random() * availableTypes.length)];
            
            let color;
            switch(randomType) {
                case 'attack': color = colors.powerUpAttack; break;
                case 'fireRate': color = colors.powerUpFireRate; break;
                case 'multiShot': color = colors.powerUpMultiShot; break;
                case 'health': color = colors.powerUpHealth; break;
            }
            
            powerUps.push({
                x: x,
                y: y,
                width: 20,
                height: 20,
                speed: 2,
                type: randomType,
                color: color
            });
        }
        
        // åˆ›å»ºç©å®¶å­å¼¹
        function createBullet() {
            const bulletCount = player.stats.multiShot;
            const spreadAngle = Math.min(30, (bulletCount - 1) * 8);
            const actualAttack = calculateActualAttack(player.stats.attack);
            const damageRatio = calculateMultiShotDamageRatio(bulletCount);
            
            for (let i = 0; i < bulletCount; i++) {
                let angle = 0;
                if (bulletCount > 1) {
                    angle = -spreadAngle / 2 + (spreadAngle / (bulletCount - 1)) * i;
                }
                
                const radians = angle * Math.PI / 180;
                
                bullets.push({
                    x: player.x + player.width / 2 - 3,
                    y: player.y,
                    width: 6,
                    height: 15,
                    speed: 10,
                    damage: actualAttack * damageRatio,
                    angle: radians,
                    color: '#f1c40f'
                });
            }
        }
        
        // å¯åŠ¨è‡ªåŠ¨å°„å‡»
        function startAutoFire() {
            if (player.autoFireInterval) {
                clearInterval(player.autoFireInterval);
            }
            
            const actualFireRate = calculateActualFireRate(player.stats.fireRate);
            const fireInterval = 200 / actualFireRate;
            
            player.autoFireInterval = setInterval(() => {
                if (player.isAlive && !gameOverElement.style.display) {
                    createBullet();
                }
            }, fireInterval);
        }
        
        // åˆ›å»ºæ•Œæœºå­å¼¹
        function createEnemyBullet(enemy, pattern = null) {
            // æ ¹æ®æ•Œæœºç±»å‹å†³å®šå­å¼¹ç±»å‹
            let bulletType = "normal";
            let bulletCount = 1;
            let spreadAngle = 0;
            let startAngle = 90; // å‘ä¸‹å‘å°„
            
            if (enemy.special === "burst" || 
                (enemy.special === "multiAttack" && enemy.currentPhase > 0)) {
                bulletCount = 3;
                spreadAngle = 30;
            }
            
            // Bossç‰¹æ®Šæ”»å‡»æ¨¡å¼
            if (enemy.isBoss) {
                const bossType = bossTypes[enemy.bossType];
                
                // æ ¹æ®Bossç±»å‹å’Œå½“å‰é˜¶æ®µå†³å®šæ”»å‡»æ¨¡å¼
                if (enemy.special === "bulletHell") {
                    pattern = pattern || enemy.bulletPatterns[enemy.currentPhase % enemy.bulletPatterns.length];
                    
                    switch(pattern) {
                        case "spiral":
                            bulletCount = 6;
                            spreadAngle = 360;
                            startAngle = (gameTime * 10) % 360; // æ—‹è½¬è§’åº¦
                            break;
                        case "wave":
                            bulletCount = 3;
                            spreadAngle = 60;
                            startAngle = 90 + Math.sin(gameTime * 0.1) * 30; // æ³¢æµªè§’åº¦
                            break;
                        case "random":
                            bulletCount = 6;
                            // éšæœºè§’åº¦
                            for (let i = 0; i < bulletCount; i++) {
                                const randomAngle = Math.random() * 360;
                                const radians = randomAngle * Math.PI / 180;
                                
                                enemyBullets.push({
                                    x: enemy.x + enemy.width / 2 - enemy.bulletSize/2,
                                    y: enemy.y + enemy.height / 2,
                                    width: enemy.bulletSize,
                                    height: enemy.bulletSize,
                                    speed: 3 + Math.random() * 2,
                                    damage: 1,
                                    angle: radians,
                                    color: '#c0392b',
                                    type: "random"
                                });
                            }
                            return;
                        case "targeted":
                            bulletCount = 3;
                            // ç„å‡†ç©å®¶
                            const dx = player.x + player.width/2 - (enemy.x + enemy.width/2);
                            const dy = player.y + player.height/2 - (enemy.y + enemy.height/2);
                            startAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                            spreadAngle = 30;
                            break;
                    }
                } else if (enemy.special === "combinedAttack") {
                    // è¶…çº§Bossæ ¹æ®é˜¶æ®µä½¿ç”¨ä¸åŒæ”»å‡»æ¨¡å¼
                    const phase = enemy.currentPhase;
                    if (phase === 0) {
                        // ç¬¬ä¸€é˜¶æ®µ: ç®€å•æ”»å‡»
                        bulletCount = 3;
                        spreadAngle = 30;
                    } else if (phase === 1) {
                        // ç¬¬äºŒé˜¶æ®µ: èºæ—‹æ”»å‡»
                        bulletCount = 6;
                        spreadAngle = 360;
                        startAngle = (gameTime * 10) % 360;
                    } else {
                        // æœ€ç»ˆé˜¶æ®µ: ç„å‡†æ”»å‡»
                        bulletCount = 3;
                        const dx = player.x + player.width/2 - (enemy.x + enemy.width/2);
                        const dy = player.y + player.height/2 - (enemy.y + enemy.height/2);
                        startAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                        spreadAngle = 45;
                    }
                }
            }
            
            for (let i = 0; i < bulletCount; i++) {
                let angle = startAngle;
                if (bulletCount > 1) {
                    if (spreadAngle === 360) {
                        // åœ†å½¢å‘å°„
                        angle = startAngle + (360 / bulletCount) * i;
                    } else {
                        // æ‰‡å½¢å‘å°„
                        angle = startAngle - spreadAngle / 2 + (spreadAngle / (bulletCount - 1)) * i;
                    }
                }
                
                // è½¬æ¢ä¸ºå¼§åº¦
                const radians = angle * Math.PI / 180;
                
                let bulletSpeed = 4;
                let bulletColor = enemy.isClone ? enemy.color : '#e74c3c';  // å¦‚æœæ˜¯å…‹éš†ä½“ï¼Œä½¿ç”¨å…‹éš†ä½“çš„é¢œè‰²
                let bulletSize = enemy.bulletSize || 10;
                
                // Bosså­å¼¹ç‰¹æ®Šå¤„ç†
                if (enemy.isBoss) {
                    bulletSpeed = 5;
                    bulletColor = enemy.color;
                    bulletSize = enemy.bulletSize;
                }
                
                enemyBullets.push({
                    x: enemy.x + enemy.width / 2 - bulletSize/2,
                    y: enemy.y + enemy.height / 2,
                    width: bulletSize,
                    height: bulletSize,
                    speed: bulletSpeed,
                    damage: 1,
                    angle: radians,
                    color: bulletColor,
                    type: bulletType
                });
            }
        }
        
        // åˆ›å»ºæ¿€å…‰æ”»å‡»
        function createLaser(enemy) {
            const laserWidth = enemy.laserWidth || 20;
            let targetX = player.x + player.width/2;
            
            // å¦‚æœæ˜¯è¶…çº§Bossçš„æœ€ç»ˆé˜¶æ®µï¼Œåˆ›å»ºå¤šä¸ªæ¿€å…‰
            if (enemy.special === "combinedAttack" && enemy.currentPhase >= 1) {
                const laserCount = 2;
                const spacing = canvas.width / (laserCount + 1);
                
                for (let i = 0; i < laserCount; i++) {
                    const laserX = spacing * (i + 1);
                    createSingleLaser(enemy, laserX, laserWidth);
                }
            } else {
                createSingleLaser(enemy, targetX, laserWidth);
            }
        }
        
        // åˆ›å»ºå•ä¸ªæ¿€å…‰
        function createSingleLaser(enemy, targetX, laserWidth) {
            // è­¦å‘Šçº¿
            const warningLine = {
                x1: targetX,
                y1: enemy.y + enemy.height,
                x2: targetX,
                y2: canvas.height,
                width: 2,
                color: '#e74c3c',
                alpha: 1,
                warningTime: 30,
                isWarning: true
            };
            
            lasers.push(warningLine);
            
            // 1ç§’åå‘å°„å®é™…æ¿€å…‰
            setTimeout(() => {
                if (!player.isAlive) return;
                
                const laser = {
                    x1: targetX,
                    y1: enemy.y + enemy.height,
                    x2: targetX,
                    y2: canvas.height,
                    width: laserWidth,
                    color: '#c0392b',
                    alpha: 1,
                    duration: 60,
                    isWarning: false,
                    damage: enemy.laserDamage || 1
                };
                
                lasers.push(laser);
                
                // æ£€æŸ¥ç©å®¶æ˜¯å¦è¢«æ¿€å…‰å‡»ä¸­
                if (Math.abs(player.x + player.width/2 - targetX) < (player.width/2 + laserWidth/2) && !player.invincible) {
                    playerDamage();
                }
            }, 1000);
        }
        
        // åˆ›å»ºçˆ†ç‚¸ç²’å­æ•ˆæœ
        function createExplosion(x, y, color, count = 20) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                
                particles.push({
                    x: x,
                    y: y,
                    radius: Math.random() * 3 + 1,
                    color: color,
                    speed: speed,
                    angle: angle,
                    life: 30 + Math.random() * 20
                });
            }
        }
        
        // ç©å®¶å—ä¼¤
        function playerDamage() {
            if (player.invincible) return;
            
            player.lives--;
            updateLifeDisplay();
            
            if (player.lives <= 0) {
                gameOver();
            } else {
                // è®¾ç½®çŸ­æš‚æ— æ•Œæ—¶é—´
                player.invincible = true;
                player.invincibleTime = 120; // 2ç§’æ— æ•Œ(60fps)
                
                // å—ä¼¤é—ªçƒæ•ˆæœ
                player.blinkTime = 0;
                
                // å—ä¼¤çˆ†ç‚¸æ•ˆæœ
                createExplosion(player.x + player.width/2, player.y + player.height/2, colors.playerDamaged, 10);
            }
        }
        
        // ç¢°æ’æ£€æµ‹
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        // ç‚¹ä¸çŸ©å½¢ç¢°æ’æ£€æµ‹
        function pointRectCollision(px, py, rect) {
            return px >= rect.x && px <= rect.x + rect.width &&
                   py >= rect.y && py <= rect.y + rect.height;
        }
        
        // ç»˜åˆ¶ä¸åŒå½¢çŠ¶çš„æ•Œæœº
        function drawEnemy(enemy) {
            ctx.fillStyle = enemy.color;
            
            switch(enemy.shape) {
                case "triangle":
                    ctx.beginPath();
                    ctx.moveTo(enemy.x + enemy.width/2, enemy.y);
                    ctx.lineTo(enemy.x, enemy.y + enemy.height);
                    ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case "rectangle":
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    break;
                    
                case "diamond":
                    ctx.beginPath();
                    ctx.moveTo(enemy.x + enemy.width/2, enemy.y);
                    ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height/2);
                    ctx.lineTo(enemy.x + enemy.width/2, enemy.y + enemy.height);
                    ctx.lineTo(enemy.x, enemy.y + enemy.height/2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case "circle":
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case "hexagon":
                    ctx.beginPath();
                    const hexRadius = enemy.width / 2;
                    const hexCenter = {x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2};
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = hexCenter.x + hexRadius * Math.cos(angle);
                        const y = hexCenter.y + hexRadius * Math.sin(angle);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case "shield":
                    // ç›¾å½¢
                    ctx.beginPath();
                    ctx.moveTo(enemy.x + enemy.width/2, enemy.y);
                    ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height/3);
                    ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height*2/3);
                    ctx.lineTo(enemy.x + enemy.width/2, enemy.y + enemy.height);
                    ctx.lineTo(enemy.x, enemy.y + enemy.height*2/3);
                    ctx.lineTo(enemy.x, enemy.y + enemy.height/3);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case "star":
                    // æ˜Ÿå½¢
                    ctx.beginPath();
                    const starCenter = {x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2};
                    const outerRadius = enemy.width / 2;
                    const innerRadius = enemy.width / 4;
                    
                    for (let i = 0; i < 10; i++) {
                        const angle = (Math.PI / 5) * i - Math.PI / 2;
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const x = starCenter.x + radius * Math.cos(angle);
                        const y = starCenter.y + radius * Math.sin(angle);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case "boss":
                    // æ ‡å‡†Bosså½¢çŠ¶
                    ctx.beginPath();
                    ctx.moveTo(enemy.x, enemy.y + enemy.height/3);
                    ctx.lineTo(enemy.x + enemy.width/4, enemy.y);
                    ctx.lineTo(enemy.x + enemy.width*3/4, enemy.y);
                    ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height/3);
                    ctx.lineTo(enemy.x + enemy.width*5/6, enemy.y + enemy.height);
                    ctx.lineTo(enemy.x + enemy.width/6, enemy.y + enemy.height);
                    ctx.closePath();
                    ctx.fill();
                    
                    // æ·»åŠ ç»†èŠ‚
                    ctx.fillStyle = "#7f8c8d";
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width/4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = "#c0392b";
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width/6, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case "shieldBoss":
                    // æŠ¤ç›¾Bosså½¢çŠ¶
                    ctx.beginPath();
                    ctx.moveTo(enemy.x + enemy.width/2, enemy.y);
                    ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height/3);
                    ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height*2/3);
                    ctx.lineTo(enemy.x + enemy.width/2, enemy.y + enemy.height);
                    ctx.lineTo(enemy.x, enemy.y + enemy.height*2/3);
                    ctx.lineTo(enemy.x, enemy.y + enemy.height/3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // ä¸­å¤®èƒ½é‡æ ¸å¿ƒ
                    ctx.fillStyle = "#2980b9";
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width/3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // å†…éƒ¨èƒ½é‡
                    ctx.fillStyle = "#3498db";
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width/5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case "cloneBoss":
                    // åˆ†èº«Bosså½¢çŠ¶
                    ctx.beginPath();
                    const segments = 8;
                    const centerX = enemy.x + enemy.width/2;
                    const centerY = enemy.y + enemy.height/2;
                    const radius = enemy.width/2;
                    
                    for (let i = 0; i < segments; i++) {
                        const angle = (Math.PI * 2 / segments) * i;
                        const x = centerX + radius * Math.cos(angle);
                        const y = centerY + radius * Math.sin(angle);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // ä¸­å¤®è¿æ¥ç‚¹
                    ctx.fillStyle = "#16a085";
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // å†…éƒ¨æ ¸å¿ƒ
                    ctx.fillStyle = "#1abc9c";
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius/4, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case "bulletHellBoss":
                    // å¼¹å¹•Bosså½¢çŠ¶
                    ctx.beginPath();
                    ctx.moveTo(enemy.x + enemy.width/2, enemy.y);
                    ctx.lineTo(enemy.x + enemy.width*3/4, enemy.y + enemy.height/4);
                    ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height/2);
                    ctx.lineTo(enemy.x + enemy.width*3/4, enemy.y + enemy.height*3/4);
                    ctx.lineTo(enemy.x + enemy.width/2, enemy.y + enemy.height);
                    ctx.lineTo(enemy.x + enemy.width/4, enemy.y + enemy.height*3/4);
                    ctx.lineTo(enemy.x, enemy.y + enemy.height/2);
                    ctx.lineTo(enemy.x + enemy.width/4, enemy.y + enemy.height/4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // å†…éƒ¨è£…é¥°
                    ctx.fillStyle = "#9b59b6";
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width/3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // æ—‹è½¬çš„èƒ½é‡ç‚¹
                    const time = Date.now() / 1000;
                    for (let i = 0; i < 4; i++) {
                        const angle = time + i * Math.PI/2;
                        const orbitRadius = enemy.width/3;
                        const dotX = enemy.x + enemy.width/2 + Math.cos(angle) * orbitRadius;
                        const dotY = enemy.y + enemy.height/2 + Math.sin(angle) * orbitRadius;
                        
                        ctx.fillStyle = "#8e44ad";
                        ctx.beginPath();
                        ctx.arc(dotX, dotY, enemy.width/10, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case "laserBoss":
                    // æ¿€å…‰Bosså½¢çŠ¶
                    ctx.beginPath();
                    ctx.moveTo(enemy.x + enemy.width/2, enemy.y);
                    ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height/2);
                    ctx.lineTo(enemy.x + enemy.width*3/4, enemy.y + enemy.height);
                    ctx.lineTo(enemy.x + enemy.width/4, enemy.y + enemy.height);
                    ctx.lineTo(enemy.x, enemy.y + enemy.height/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // ä¸­å¤®æ¿€å…‰å‘å°„å™¨
                    ctx.fillStyle = "#d35400";
                    ctx.fillRect(enemy.x + enemy.width/4, enemy.y + enemy.height*2/3, enemy.width/2, enemy.height/3);
                    
                    // æ¿€å…‰å……èƒ½æ•ˆæœ
                    const timeSinceLastLaser = Date.now() - (enemy.lastLaserAttack || 0);
                    const chargeRatio = Math.min(1, timeSinceLastLaser / enemy.laserCooldown);
                    
                    ctx.fillStyle = "#e67e22";
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height*3/4, enemy.width/6 * chargeRatio, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case "superBoss":
                    // è¶…çº§Boss - æ›´å¤æ‚çš„å½¢çŠ¶
                    // ä¸»ä½“
                    ctx.fillStyle = "#7f8c8d";
                    ctx.beginPath();
                    ctx.moveTo(enemy.x, enemy.y + enemy.height/2);
                    ctx.lineTo(enemy.x + enemy.width/4, enemy.y);
                    ctx.lineTo(enemy.x + enemy.width*3/4, enemy.y);
                    ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height/2);
                    ctx.lineTo(enemy.x + enemy.width*3/4, enemy.y + enemy.height);
                    ctx.lineTo(enemy.x + enemy.width/4, enemy.y + enemy.height);
                    ctx.closePath();
                    ctx.fill();
                    
                    // ä¸­å¿ƒæ ¸å¿ƒ
                    ctx.fillStyle = "#c0392b";
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width/4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // èƒ½é‡ç¯
                    ctx.strokeStyle = "#e74c3c";
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width/3, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ç‚®å¡”
                    ctx.fillStyle = "#2c3e50";
                    ctx.fillRect(enemy.x + enemy.width/4, enemy.y + enemy.height*3/4, enemy.width/10, enemy.height/6);
                    ctx.fillRect(enemy.x + enemy.width*7/10, enemy.y + enemy.height*3/4, enemy.width/10, enemy.height/6);
                    
                    // ç›¸ä½æŒ‡ç¤ºå™¨
                    const phaseIndicatorSize = 8;
                    for (let i = 0; i < enemy.phaseThresholds.length + 1; i++) {
                        ctx.fillStyle = i <= enemy.currentPhase ? "#2ecc71" : "#7f8c8d";
                        ctx.beginPath();
                        ctx.arc(enemy.x + enemy.width/2 - (enemy.phaseThresholds.length * phaseIndicatorSize) / 2 + i * phaseIndicatorSize, 
                                enemy.y - 15, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                
                default:
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
            }
            
            // ç»˜åˆ¶æŠ¤ç›¾ï¼ˆå¦‚æœæœ‰ï¼‰
            if (enemy.shield > 0) {
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 
                        enemy.width/2 + 5, 0, Math.PI * 2);
                ctx.stroke();
                
                // æŠ¤ç›¾è¡€é‡æ¡
                const shieldPercentage = enemy.shield / enemy.maxShield;
                ctx.fillStyle = '#3498db';
                ctx.fillRect(enemy.x, enemy.y - 15, enemy.width * shieldPercentage, 3);
            }
            
            // ç»˜åˆ¶è¡€æ¡
            const hpPercentage = enemy.hp / enemy.maxHp;
            ctx.fillStyle = '#555';
            ctx.fillRect(enemy.x, enemy.y - 10, enemy.width, 5);
            ctx.fillStyle = hpPercentage > 0.5 ? '#2ecc71' : (hpPercentage > 0.2 ? '#f39c12' : '#e74c3c');
            ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * hpPercentage, 5);
            
            // Bossåç§°æ˜¾ç¤º
            if (enemy.isBoss) {
                const bossType = bossTypes[enemy.bossType];
                ctx.fillStyle = '#fff';
                ctx.font = '14px Arial';
                const textWidth = ctx.measureText(bossType.name).width;
                ctx.fillText(bossType.name, enemy.x + enemy.width/2 - textWidth/2, enemy.y - 20);
            }
        }

        const playerImage = new Image(); // åŠ è½½ç©å®¶å›¾ç‰‡
        playerImage.src = "./img/togawa.jpeg";
        
        function drawPlayer(playerX, playerY, playerWidth, playerHeight) { // æ–°çš„ç©å®¶ç»˜åˆ¶æ–¹æ³•
            if (playerImage.complete) {
                ctx.drawImage(playerImage, playerX, playerY, playerWidth, playerHeight);
            } else {
                // å¦‚æœå›¾ç‰‡æœªåŠ è½½å®Œæˆï¼Œä½¿ç”¨åŸæ¥çš„é¢œè‰²ç»˜åˆ¶
                ctx.fillStyle = colors.player;
                ctx.fillRect(playerX, playerY, playerWidth, playerHeight);
            }
        }

        // æ›´æ–°ç©å®¶
        function updatePlayer() {
            // å¤„ç†æ— æ•Œæ—¶é—´
            if (player.invincible) {
                player.invincibleTime--;
                player.blinkTime++;
                
                if (player.invincibleTime <= 0) {
                    player.invincible = false;
                }
            }
            
            // ä¸æ»‘ç§»åŠ¨å¤„ç†
            if (keys.left) {
                player.x -= player.speedX;
                player.tilt = -15;
            } else if (keys.right) {
                player.x += player.speedX;
                player.tilt = 15;
            } else {
                player.tilt = player.tilt * 0.8;
                if (Math.abs(player.tilt) < 0.1) player.tilt = 0;
            }
            
            // ä¸Šä¸‹ç§»åŠ¨
            if (keys.up) {
                player.y = Math.max(player.movementBounds.minY, player.y - player.speedY);
            } else if (keys.down) {
                player.y = Math.min(player.movementBounds.maxY, player.y + player.speedY);
            }
            
            // è¾¹ç•Œæ£€æŸ¥
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
            
            // ç»˜åˆ¶ç©å®¶ (é—ªçƒæ•ˆæœ)
            if (!player.invincible || player.blinkTime % 10 < 5) {
                ctx.save();
                ctx.translate(player.x + player.width/2, player.y + player.height/2);
                ctx.rotate(player.tilt * Math.PI / 180);
                ctx.fillStyle = player.invincible ? colors.playerDamaged : colors.player;
                ctx.fillRect(-player.width/2, -player.height/2, player.width, player.height);
                
                drawPlayer(-player.width/2, -player.height/2, player.width, player.height);
                
                // é£æœºç»†èŠ‚
                ctx.fillStyle = '#fff';
                ctx.fillRect(-2, -player.height/2 - 5, 4, 5);

                ctx.restore();
            }
        }
        
        // æ›´æ–°å­å¼¹
        function updateBullets() {
            bullets = bullets.filter(bullet => {
                // æ ¹æ®è§’åº¦æ›´æ–°å­å¼¹ä½ç½®
                bullet.x += Math.sin(bullet.angle) * bullet.speed;
                bullet.y -= Math.cos(bullet.angle) * bullet.speed;
                
                // ç»˜åˆ¶å­å¼¹
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                
                return bullet.y > -bullet.height && 
                       bullet.x > -bullet.width && 
                       bullet.x < canvas.width;
            });
            
            // æ›´æ–°æ•Œæœºå­å¼¹
            enemyBullets = enemyBullets.filter(bullet => {
                // æ ¹æ®è§’åº¦æ›´æ–°å­å¼¹ä½ç½®
                bullet.x += Math.cos(bullet.angle) * bullet.speed;
                bullet.y += Math.sin(bullet.angle) * bullet.speed;
                
                // ç»˜åˆ¶å­å¼¹
                ctx.fillStyle = bullet.color;
                // ctx.beginPath();
                // ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, bullet.width/2, 0, Math.PI * 2);
                // ctx.fill();
                drawHeartBullet(bullet);
                
                // æ£€æµ‹ä¸ç©å®¶çš„ç¢°æ’
                if (checkCollision(bullet, player) && !player.invincible) {
                    playerDamage();
                    return false;
                }
                
                return bullet.y < canvas.height && 
                       bullet.x > -bullet.width && 
                       bullet.x < canvas.width;
            });
        }
        
        // æ›´æ–°æ¿€å…‰
        function updateLasers() {
            lasers = lasers.filter(laser => {
                if (laser.isWarning) {
                    // è­¦å‘Šçº¿
                    ctx.strokeStyle = laser.color;
                    ctx.lineWidth = laser.width;
                    ctx.globalAlpha = 0.5 + 0.5 * Math.sin(laser.warningTime * 0.2);
                    ctx.beginPath();
                    ctx.moveTo(laser.x1, laser.y1);
                    ctx.lineTo(laser.x2, laser.y2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    
                    laser.warningTime--;
                    return laser.warningTime > 0;
                } else {
                    // å®é™…æ¿€å…‰
                    ctx.strokeStyle = laser.color;
                    ctx.lineWidth = laser.width;
                    ctx.beginPath();
                    ctx.moveTo(laser.x1, laser.y1);
                    ctx.lineTo(laser.x2, laser.y2);
                    ctx.stroke();
                    
                    // æ¿€å…‰ç²’å­æ•ˆæœ
                    for (let i = 0; i < 3; i++) {
                        const y = laser.y1 + Math.random() * (laser.y2 - laser.y1);
                        createExplosion(laser.x1, y, laser.color, 2);
                    }
                    
                    // æ£€æŸ¥ç©å®¶æ˜¯å¦è¢«æ¿€å…‰å‡»ä¸­
                    if (!player.invincible && laser.duration % 10 === 0) {
                        const playerCenterX = player.x + player.width/2;
                        if (Math.abs(playerCenterX - laser.x1) < (player.width/2 + laser.width/2)) {
                            playerDamage();
                        }
                    }
                    
                    laser.duration--;
                    return laser.duration > 0;
                }
            });
        }
        
        // æ›´æ–°æ•Œæœº
        function updateEnemies() {
            enemies = enemies.filter(enemy => {
                // æ ¹æ®ç§»åŠ¨æ¨¡å¼æ›´æ–°æ•Œæœºä½ç½®
                enemy.movementTime += 0.016; // å‡è®¾60FPSï¼Œæ¯å¸§çº¦16ms

                // åŸºæœ¬å‚ç›´ç§»åŠ¨ - å¯¹äºéBossæ•Œæœº
                if (!enemy.isBoss) {
                    enemy.y += enemy.speed;
                }

                // æ ¹æ®ç§»åŠ¨æ¨¡å¼æ·»åŠ æ°´å¹³ç§»åŠ¨
                switch(enemy.movementPattern) {
                    case "zigzag":
                        // é”¯é½¿å½¢ç§»åŠ¨
                        if (Math.floor(enemy.movementTime / 0.5) % 2 === 0) {
                            enemy.x += enemy.speed * 0.8;
                        } else {
                            enemy.x -= enemy.speed * 0.8;
                        }
                        break;
                    case "sine":
                        // æ­£å¼¦æ³¢ç§»åŠ¨
                        enemy.x = enemy.initialX + Math.sin(enemy.movementTime * enemy.frequency) * enemy.amplitude;
                        break;
                    case "tracking":
                        // è¿½è¸ªç©å®¶
                        if (player.x + player.width/2 > enemy.x + enemy.width/2) {
                            enemy.x += enemy.speed * 0.5;
                        } else {
                            enemy.x -= enemy.speed * 0.5;
                        }
                        break;
                    case "bounce":
                        // å¼¹è·³ç§»åŠ¨
                        enemy.x += enemy.speed * enemy.direction;
                        if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) {
                            enemy.direction *= -1;
                        }
                        break;
                    case "circle":
                        // åœ†å½¢ç§»åŠ¨
                        enemy.x = enemy.initialX + Math.sin(enemy.movementTime * 2) * enemy.amplitude/2;
                        enemy.y += Math.cos(enemy.movementTime * 2) * 0.5 + enemy.speed * 0.8;
                        break;
                    case "complex":
                        // å¤æ‚ç§»åŠ¨
                        enemy.x = enemy.initialX + Math.sin(enemy.movementTime) * enemy.amplitude * 
                                 Math.sin(enemy.movementTime * 0.3);
                        break;
                    case "clone":
                        // å…‹éš†ä½“ç§»åŠ¨ - å›´ç»•Bossç§»åŠ¨è€Œä¸æ˜¯ç©å®¶
                        const angle = enemy.movementTime * 1.5;
                        const orbitDistance = 100; // å‡å°è½¨é“åŠå¾„
                        const centerX = enemy.parentBoss.x + enemy.parentBoss.width/2;
                        const centerY = enemy.parentBoss.y + enemy.parentBoss.height/2;
                        
                        enemy.x = centerX - enemy.width/2 + Math.cos(angle) * orbitDistance;
                        enemy.y = centerY - enemy.height/2 + Math.sin(angle) * orbitDistance;
                        
                        // ç¡®ä¿å…‹éš†ä½“ä¸ä¼šç§»å‡ºå±å¹•
                        enemy.x = Math.max(0, Math.min(canvas.width - enemy.width, enemy.x));
                        enemy.y = Math.max(0, Math.min(canvas.height/2, enemy.y));
                        break;
                    case "boss":
                        // æ ‡å‡†Bossç§»åŠ¨æ¨¡å¼
                        if (enemy.y < 100) {
                            enemy.y += enemy.speed * 0.5; // ç¼“æ…¢ä¸‹é™åˆ°ä½ç½®
                        } else {
                            // ç„¶ååœ¨é¡¶éƒ¨åŒºåŸŸå·¦å³ç§»åŠ¨
                            enemy.y = 100; // å›ºå®šYåæ ‡
                            enemy.x = canvas.width/2 - enemy.width/2 + 
                                     Math.sin(enemy.movementTime * 0.5) * (canvas.width/2 - enemy.width);
                        }
                        break;
                    case "shieldBoss":
                        if (enemy.y < 120) {
                            enemy.y += enemy.speed * 0.5; // ç¼“æ…¢ä¸‹é™åˆ°ä½ç½®
                        } else {
                            enemy.y = 120 + Math.sin(enemy.movementTime * 0.2) * 30;
                            enemy.x = canvas.width/2 - enemy.width/2 + 
                                     Math.sin(enemy.movementTime * 0.3) * (canvas.width/3);

                            // æŠ¤ç›¾å†ç”Ÿ
                            const currentTime = Date.now();
                            if (enemy.shield < enemy.maxShield && 
                                currentTime - enemy.lastShieldRegen > 1000) {
                                enemy.shield = Math.min(enemy.maxShield, enemy.shield + enemy.shieldRegenRate * enemy.maxShield);
                                enemy.lastShieldRegen = currentTime;
                            }
                        }
                        break;
                    case "cloneBoss":
                        if (enemy.y < 100) {
                            enemy.y += enemy.speed * 0.5; // ç¼“æ…¢ä¸‹é™åˆ°ä½ç½®
                        } else {
                            enemy.y = 100; // å›ºå®šYåæ ‡
                            enemy.x = canvas.width/2 - enemy.width/2 + 
                                     Math.sin(enemy.movementTime) * (canvas.width/3 - enemy.width);

                            // å…‹éš†ä½“ç”Ÿæˆé€»è¾‘
                            if (!enemy.lastCloneCreation) {
                                enemy.lastCloneCreation = Date.now();
                                enemy.clonesCreated = 0;
                            }

                            const currentClones = clones.filter(c => c.parentBoss === enemy).length;
                            const currentTime = Date.now();

                            if (currentClones < enemy.cloneCount && 
                                currentTime - enemy.lastCloneCreation >= 3000 && 
                                enemy.clonesCreated < enemy.cloneCount) {
                                createBossClone(enemy);
                                enemy.lastCloneCreation = currentTime;
                                enemy.clonesCreated++;
                            }
                        }
                        break;
                    case "bulletHellBoss":
                        if (enemy.y < 80) {
                            enemy.y += enemy.speed * 0.5; // ç¼“æ…¢ä¸‹é™åˆ°ä½ç½®
                        } else {
                            enemy.y = 80 + Math.sin(enemy.movementTime * 0.7) * 40;
                            enemy.x = canvas.width/2 - enemy.width/2 + 
                                     Math.sin(enemy.movementTime * 0.5) * (canvas.width/3) *
                                     Math.cos(enemy.movementTime * 0.3);
                        }
                        break;
                    case "laserBoss":
                        if (enemy.y < 70) {
                            enemy.y += enemy.speed * 0.5; // ç¼“æ…¢ä¸‹é™åˆ°ä½ç½®
                        } else {
                            enemy.y = 70; // å›ºå®šYåæ ‡
                            enemy.x = canvas.width/2 - enemy.width/2 + 
                                     Math.sin(enemy.movementTime * 0.2) * (canvas.width/3);

                            // æ¿€å…‰æ”»å‡»
                            const laserTime = Date.now();
                            if (laserTime - enemy.lastLaserAttack > enemy.laserCooldown) {
                                createLaser(enemy);
                                enemy.lastLaserAttack = laserTime;
                            }
                        }
                        break;
                    case "superBoss":
                        if (enemy.y < 100) {
                            enemy.y += enemy.speed * 0.5; // ç¼“æ…¢ä¸‹é™åˆ°ä½ç½®
                        } else {
                            enemy.y = 100 + Math.sin(enemy.movementTime * 0.2) * 30;
                            enemy.x = canvas.width/2 - enemy.width/2 + 
                                     Math.sin(enemy.movementTime * 0.3) * (canvas.width/4);

                            // æ ¹æ®å½“å‰é˜¶æ®µæ‰§è¡Œä¸åŒæ”»å‡»
                            const superTime = Date.now();
                            const phase = enemy.currentPhase;

                            // æŠ¤ç›¾å†ç”Ÿ
                            if (phase >= 0 && enemy.shield < enemy.maxShield && 
                                superTime - enemy.lastShieldRegen > 2000) {
                                enemy.shield = Math.min(enemy.maxShield, enemy.shield + enemy.shieldRegenRate * enemy.maxShield);
                                enemy.lastShieldRegen = superTime;
                            }

                            // åˆ›å»ºåˆ†èº«
                            if (phase >= 1 && superTime - enemy.lastCloneCreation > 10000) {
                                createBossClone(enemy);
                                enemy.lastCloneCreation = superTime;
                            }

                            // æ¿€å…‰æ”»å‡»
                            if (phase >= 1 && superTime - enemy.lastLaserAttack > enemy.laserCooldown) {
                                createLaser(enemy);
                                enemy.lastLaserAttack = superTime;
                            }
                        }
                        break;
                }                
                
                // è¾¹ç•Œæ£€æŸ¥ - ç¡®ä¿æ•Œæœºä¸ä¼šç§»å‡ºå±å¹•ä¸¤ä¾§
                enemy.x = Math.max(0, Math.min(canvas.width - enemy.width, enemy.x));
                
                // æ•Œæœºå°„å‡»é€»è¾‘
                if (Math.random() < enemy.shootRate) {
                    const currentTime = Date.now();
                    if (currentTime - enemy.lastShot > 1000) { // è‡³å°‘1ç§’é—´éš”
                        createEnemyBullet(enemy);
                        enemy.lastShot = currentTime;
                    }
                }
                
                // ç»˜åˆ¶æ•Œæœº
                drawEnemy(enemy);
                
                // Bossé˜¶æ®µæ£€æŸ¥
                if (enemy.phaseThresholds && enemy.hp / enemy.maxHp <= enemy.phaseThresholds[enemy.currentPhase]) {
                    enemy.currentPhase++;
                    // é˜¶æ®µå˜åŒ–ç‰¹æ•ˆ
                    createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#f39c12', 50);
                    
                    // å¦‚æœæ˜¯å¼¹å¹•Bossï¼Œæ¯ä¸ªé˜¶æ®µå‘å°„ä¸€è½®å¼¹å¹•
                    if (enemy.special === "bulletHell") {
                        for (let pattern of enemy.bulletPatterns) {
                            setTimeout(() => {
                                if (enemy.hp > 0) createEnemyBullet(enemy, pattern);
                            }, Math.random() * 1000);
                        }
                    }
                }
                
                // æ£€æµ‹å­å¼¹ç¢°æ’
                let destroyed = false;
                
                for (let i = bullets.length - 1; i >= 0; i--) {
                    if (checkCollision(bullets[i], enemy)) {
                        // è®¡ç®—ä¼¤å®³ï¼Œè€ƒè™‘æŠ—æ€§
                        const damage = bullets[i].damage * (1 - enemy.resistance);
                        
                        // å¦‚æœæœ‰æŠ¤ç›¾ï¼Œå…ˆæ‰£é™¤æŠ¤ç›¾
                        if (enemy.shield > 0) {
                            enemy.shield -= damage;
                            if (enemy.shield < 0) {
                                // æŠ¤ç›¾ç ´ç¢ï¼Œå‰©ä½™ä¼¤å®³ä¼ é€’ç»™æ•Œæœº
                                enemy.hp += enemy.shield;
                                enemy.shield = 0;
                            }
                        } else {
                            // ç›´æ¥æ‰£é™¤æ•Œæœºè¡€é‡
                            enemy.hp -= damage;
                        }
                        
                        // ç§»é™¤å­å¼¹
                        bullets.splice(i, 1);
                        
                        // æ£€æŸ¥æ•Œæœºæ˜¯å¦è¢«æ‘§æ¯
                        if (enemy.hp <= 0) {
                            destroyed = true;
                            score += enemy.score;
                            scoreElement.textContent = `å¾—åˆ†: ${score}`;
                            
                            // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
                            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.color);
                            
                            // å¢åŠ å‡»è´¥æ•Œäººè®¡æ•°
                            if (!enemy.isBoss && !enemy.isClone && bossSpawned == 0) {
                                enemiesDefeated++;
                                updateWaveProgress();
                                
                                // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°Bosså‡ºç°æ¡ä»¶
                                if (enemiesDefeated >= enemiesRequiredForBoss) {
                                    createBoss();
                                }
                            }
                            
                            // åªæœ‰Bossæ‰è½é“å…·
                            if (enemy.isBoss) {
                                // å‡å°‘Bossè®¡æ•°
                                bossSpawned--;
                                
                                // æ ¹æ®æ³¢æ•°è°ƒæ•´é“å…·æ‰è½æ•°é‡
                                const maxDrops = Math.min(3, 1 + Math.floor(waveNumber / 5));
                                const dropCount = Math.floor(Math.random() * maxDrops) + 1;
                                
                                // ç¡®ä¿ç”Ÿå‘½å€¼é“å…·çš„æ‰è½
                                if (player.lives < player.maxLives) {
                                    setTimeout(() => {
                                        createPowerUp(
                                            enemy.x + enemy.width/2,
                                            enemy.y + enemy.height/2,
                                            'health'
                                        );
                                    }, 500);
                                }
                                
                                // å…¶ä»–é“å…·æ‰è½
                                for (let j = 0; j < dropCount; j++) {
                                    setTimeout(() => {
                                        const availableTypes = [];
                                        if (player.stats.attack < player.maxStats.attack) availableTypes.push('attack');
                                        if (player.stats.fireRate < player.maxStats.fireRate) availableTypes.push('fireRate');
                                        if (player.stats.multiShot < player.maxStats.multiShot) availableTypes.push('multiShot');
                                        
                                        if (availableTypes.length > 0) {
                                            const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                                            createPowerUp(
                                                enemy.x + Math.random() * enemy.width,
                                                enemy.y + Math.random() * enemy.height,
                                                type
                                            );
                                        }
                                    }, j * 300);
                                }
                                
                                // æ¸…é™¤Bossä¿¡æ¯
                                bossInfoElement.style.display = 'none';
                                
                                // è¿›å…¥ä¸‹ä¸€æ³¢
                                setTimeout(() => {
                                    nextWave();
                                }, 2000);
                            }
                            
                            // åˆ†è£‚æ•Œæœºç‰¹æ®Šèƒ½åŠ›
                            if (enemy.special === "split" && !enemy.hasSplit) {
                                // åˆ›å»ºä¸¤ä¸ªåˆ†è£‚ä½“
                                createSplitEnemy(enemy, 'left');
                                createSplitEnemy(enemy, 'right');
                            }
                            
                            break;
                        }
                    }
                }
                
                // æ£€æµ‹ç©å®¶ç¢°æ’
                if (!destroyed && checkCollision(enemy, player) && !player.invincible) {
                    playerDamage();
                }
                
                // Bosså’Œåˆ†èº«ä¸ä¼šç§»å‡ºå±å¹•
                if (enemy.isBoss || enemy.isClone) {
                    return !destroyed;
                }
                
                // æ™®é€šæ•Œæœºå¯ä»¥ç§»å‡ºå±å¹•åº•éƒ¨
                return !destroyed && enemy.y < canvas.height + 100;
            });
        }
        
        // æ›´æ–°èƒ½åŠ›é“å…·
        function updatePowerUps() {
            powerUps = powerUps.filter(powerUp => {
                powerUp.y += powerUp.speed;
                
                // ç»˜åˆ¶é“å…·
                ctx.fillStyle = powerUp.color;
                ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                
                // ç»˜åˆ¶é“å…·æ ‡è¯†
                ctx.fillStyle = '#fff';
                ctx.font = '14px Arial';
                let symbol = '';
                switch(powerUp.type) {
                    case 'attack': symbol = 'A'; break;
                    case 'fireRate': symbol = 'F'; break;
                    case 'multiShot': symbol = 'M'; break;
                    case 'health': symbol = 'H'; break;
                }
                ctx.fillText(symbol, powerUp.x + 6, powerUp.y + 15);
                
                // æ£€æµ‹ç©å®¶ç¢°æ’
                if (checkCollision(powerUp, player)) {
                    // åº”ç”¨èƒ½åŠ›æå‡
                    if (powerUp.type === 'health') {
                        if (player.lives < player.maxLives) {
                            player.lives++;
                            updateLifeDisplay();
                            createExplosion(player.x + player.width/2, player.y + player.height/2, '#2ecc71', 20);
                        }
                    } else {
                        // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æœ€å¤§å€¼
                        if (player.stats[powerUp.type] < player.maxStats[powerUp.type]) {
                            player.stats[powerUp.type]++;
                            createExplosion(player.x + player.width/2, player.y + player.height/2, powerUp.color, 15);
                            
                            // å¦‚æœæ˜¯æ”»å‡»é€Ÿåº¦ï¼Œæ›´æ–°è‡ªåŠ¨å°„å‡»é—´éš”
                            if (powerUp.type === 'fireRate') {
                                startAutoFire();
                            }
                        }
                    }
                    
                    // æ›´æ–°UI
                    updateStatsDisplay();
                    
                    // æ¯è·å¾—5ç‚¹èƒ½åŠ›ï¼Œæ¸¸æˆç­‰çº§+1
                    const totalStats = player.stats.attack + player.stats.fireRate + player.stats.multiShot - 3;
                    gameLevel = Math.floor(totalStats / 5) + 1;
                    
                    return false;
                }
                
                return powerUp.y < canvas.height;
            });
        }
        
        // æ›´æ–°ç²’å­æ•ˆæœ
        function updateParticles() {
            particles = particles.filter(particle => {
                particle.x += Math.cos(particle.angle) * particle.speed;
                particle.y += Math.sin(particle.angle) * particle.speed;
                particle.life--;
                
                // ç»˜åˆ¶ç²’å­
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.life / 50;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                
                return particle.life > 0;
            });
        }
        
        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatsDisplay() {
            attackElement.textContent = player.stats.attack;
            fireRateElement.textContent = player.stats.fireRate;
            multiShotElement.textContent = player.stats.multiShot;
        }
        
        // æ›´æ–°æ¸¸æˆæ—¶é—´
        function updateGameTime() {
            gameTime++;
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            gameTimeElement.textContent = `æ¸¸æˆæ—¶é—´: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // æ¸¸æˆç»“æŸ
        function gameOver() {
            player.isAlive = false;
            clearInterval(enemyGenerationInterval);
            clearInterval(gameTimeInterval);
            clearInterval(waveInterval);
            
            if (player.autoFireInterval) {
                clearInterval(player.autoFireInterval);
            }
            
            gameOverElement.style.display = 'block';
            restartBtn.style.display = 'block';
            bossInfoElement.style.display = 'none';
            
            // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
            createExplosion(player.x + player.width/2, player.y + player.height/2, colors.player, 50);
        }
        
        // é‡ç½®æ¸¸æˆ
        function resetGame() {
            player.x = canvas.width / 2 - 25;
            player.y = canvas.height - 80;
            player.isAlive = true;
            player.tilt = 0;
            player.lives = 3;
            player.invincible = false;
            player.stats = {
                attack: 1,
                fireRate: 1,
                multiShot: 1
            };
            
            bullets = [];
            enemyBullets = [];
            enemies = [];
            powerUps = [];
            particles = [];
            lasers = [];
            score = 0;
            gameLevel = 1;
            gameTime = 0;
            waveNumber = 1;
            bossSpawned = 0;
            isCreatingBoss = false; // é‡ç½®Bossåˆ›å»ºæ ‡å¿—
            enemiesDefeated = 0;
            enemiesRequiredForBoss = 12;
            enemyLimit = 6;
            currentBossType = null;  // é‡ç½®å½“å‰Bossç±»å‹
            
            scoreElement.textContent = `å¾—åˆ†: 0`;
            updateStatsDisplay();
            updateLifeDisplay();
            updateWaveProgress();
            gameTimeElement.textContent = `æ¸¸æˆæ—¶é—´: 00:00`;
            waveInfoElement.textContent = `ç¬¬1æ³¢`;
            gameOverElement.style.display = 'none';
            restartBtn.style.display = 'none';
            bossInfoElement.style.display = 'none';
            
            // æ¸…é™¤æ‰€æœ‰å®šæ—¶å™¨
            clearInterval(enemyGenerationInterval);
            clearInterval(gameTimeInterval);
            clearInterval(waveInterval);
            
            if (player.autoFireInterval) {
                clearInterval(player.autoFireInterval);
                player.autoFireInterval = null;  // ç¡®ä¿æ¸…é™¤å¼•ç”¨
            }
            
            // é‡æ–°å¯åŠ¨å®šæ—¶å™¨
            enemyGenerationInterval = setInterval(createEnemy, 1000);
            gameTimeInterval = setInterval(updateGameTime, 1000);
            
            // ç¡®ä¿é‡æ–°å¯åŠ¨è‡ªåŠ¨å°„å‡»
            setTimeout(() => {
                startAutoFire();  // ä½¿ç”¨setTimeoutç¡®ä¿åœ¨æ‰€æœ‰æ¸…ç†å·¥ä½œå®Œæˆåå¯åŠ¨
            }, 100);
            
            // é‡æ–°å¯åŠ¨æ¸¸æˆå¾ªç¯
            if (!gameStarted) {
                gameStarted = true;
                gameLoop();
            }
        }
        
        // éšæœºç”Ÿæˆæ˜Ÿæ˜ŸèƒŒæ™¯
        const stars = [];
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 1,
                speed: Math.random() * 0.5 + 0.1
            });
        }
        
        // ç»˜åˆ¶æ˜Ÿç©ºèƒŒæ™¯
        function drawBackground() {
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
            ctx.fillStyle = '#fff';
            stars.forEach(star => {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
                
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
        }
        
        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            if (!player.isAlive) {
                gameStarted = false;
                return;
            }
            
            // æ¸…é™¤ç”»å¸ƒå¹¶ç»˜åˆ¶èƒŒæ™¯
            drawBackground();
            
            // æ›´æ–°æ¸¸æˆå¯¹è±¡
            updatePlayer();
            updateBullets();
            updateLasers();
            updateEnemies();
            
            // æ›´æ–°å’Œç»˜åˆ¶å…‹éš†ä½“
            clones = clones.filter(clone => {
                if (clone.hp <= 0) return false;
                
                updateCloneMovement(clone);
                drawEnemy(clone); // ä½¿ç”¨ç›¸åŒçš„ç»˜åˆ¶å‡½æ•°
                
                // æ£€æŸ¥å­å¼¹ç¢°æ’
                bullets.forEach((bullet, index) => {
                    if (checkCollision(bullet, clone)) {
                        const damage = bullet.damage * (1 - clone.resistance);
                        clone.hp -= damage;
                        bullets.splice(index, 1);
                        
                        if (clone.hp <= 0) {
                            createExplosion(clone.x + clone.width/2, clone.y + clone.height/2, clone.color, 20);
                            score += clone.score;
                            scoreElement.textContent = `å¾—åˆ†: ${score}`;
                        }
                    }
                });
                
                // æ£€æŸ¥ä¸ç©å®¶çš„ç¢°æ’
                if (checkCollision(clone, player) && !player.invincible) {
                    playerDamage();
                }
                
                return clone.hp > 0;
            });
            
            updatePowerUps();
            updateParticles();
            
            requestAnimationFrame(gameLoop);
        }
        
        // ä¿®æ”¹è§¦æ‘¸æ§åˆ¶ä»£ç ï¼Œä½¿ç”¨ç›´æ¥æ§åˆ¶
        let touchX = null;
        let touchY = null;
        
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            touchX = touch.clientX - rect.left;
            touchY = touch.clientY - rect.top;
            
            // è®¡ç®—å®é™…åæ ‡ï¼ˆè€ƒè™‘ç”»å¸ƒç¼©æ”¾ï¼‰
            const scale = rect.width / canvas.width;
            player.x = touchX / scale - player.width / 2;
            player.y = touchY / scale - player.height / 2;
            
            // ç¡®ä¿é£æœºåœ¨è¾¹ç•Œå†…
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
            player.y = Math.max(player.movementBounds.minY, 
                               Math.min(player.movementBounds.maxY, player.y));
        });
        
        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const newTouchX = touch.clientX - rect.left;
            const newTouchY = touch.clientY - rect.top;
            
            if (touchX !== null && touchY !== null) {
                // è®¡ç®—å®é™…åæ ‡ï¼ˆè€ƒè™‘ç”»å¸ƒç¼©æ”¾ï¼‰
                const scale = rect.width / canvas.width;
                player.x = newTouchX / scale - player.width / 2;
                player.y = newTouchY / scale - player.height / 2;
                
                // ç¡®ä¿é£æœºåœ¨è¾¹ç•Œå†…
                player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
                player.y = Math.max(player.movementBounds.minY, 
                                   Math.min(player.movementBounds.maxY, player.y));
                
                // è®¡ç®—å€¾æ–œè§’åº¦
                const moveX = newTouchX - touchX;
                player.tilt = moveX * 0.1;
            }
            
            touchX = newTouchX;
            touchY = newTouchY;
        });
        
        canvas.addEventListener('touchend', function(e) {
            e.preventDefault();
            touchX = null;
            touchY = null;
            player.tilt = 0;
        });

        // åˆå§‹åŒ–ç”Ÿå‘½æ˜¾ç¤º
        updateLifeDisplay();
        
        // å¯åŠ¨è‡ªåŠ¨å°„å‡»
        startAutoFire();
        
        // å¯åŠ¨æ¸¸æˆ
        enemyGenerationInterval = setInterval(createEnemy, 1000);
        gameTimeInterval = setInterval(updateGameTime, 1000);
        updateStatsDisplay();
        updateWaveProgress();
        gameLoop();

        // è®¡ç®—å®é™…æ”»å‡»åŠ›çš„å‡½æ•°
        function calculateActualAttack(baseAttack) {
            // ä½¿ç”¨å¯¹æ•°å‡½æ•°ä½¿å¾—æ”»å‡»åŠ›å¢é•¿å˜å¾—æ›´ç¼“æ…¢
            // 1çº§æ—¶ä¼¤å®³ä¸º1ï¼Œ8çº§æ—¶ä¼¤å®³çº¦ä¸º3
            return 1 + Math.log2(baseAttack) * 0.8;
        }

        // è®¡ç®—å®é™…æ”»å‡»é€Ÿåº¦çš„å‡½æ•°
        function calculateActualFireRate(baseFireRate) {
            // ä½¿ç”¨å¯¹æ•°å‡½æ•°ä½¿å¾—æ”»å‡»é€Ÿåº¦å¢é•¿å˜å¾—æ›´ç¼“æ…¢
            // 1çº§æ—¶ä¸º1ï¼Œ8çº§æ—¶çº¦ä¸º2.5
            return 1 + Math.log2(baseFireRate) * 0.6;
        }

        // è®¡ç®—å¤šé‡å°„å‡»ä¼¤å®³ç³»æ•°çš„å‡½æ•°
        function calculateMultiShotDamageRatio(multiShot) {
            // å¤šé‡å°„å‡»æ—¶é™ä½å•å‘ä¼¤å®³
            // 2å‘æ—¶æ¯å‘ä¼¤å®³ä¸º80%ï¼Œ3å‘æ—¶æ¯å‘ä¼¤å®³ä¸º65%
            return 1 - (multiShot - 1) * 0.2;
        }

        // ä¿®æ”¹è¿›å…¥ä¸‹ä¸€æ³¢æ—¶çš„æ•°å€¼è°ƒæ•´
        function nextWave() {
            waveNumber++;
            enemiesDefeated = 0;
            waveProgressBar.style.width = '0%';
            waveInfoElement.textContent = `ç¬¬${waveNumber}æ³¢`;
            
            // å¢åŠ æ¯æ³¢éœ€è¦å‡»è´¥çš„æ•Œäººæ•°é‡ï¼ˆæ›´å¹³ç¼“çš„å¢é•¿ï¼‰
            enemiesRequiredForBoss = Math.min(24, 12 + Math.floor(waveNumber / 3));
            
            // éšæ³¢æ¬¡å¢åŠ æ•Œäººæ•°é‡ä¸Šé™ï¼ˆæ›´ä¿å®ˆçš„å¢é•¿ï¼‰
            enemyLimit = Math.min(12, 6 + Math.floor(waveNumber / 4));
        }

        // æ›´æ–°ç§»åŠ¨æ¨¡å¼å¤„ç†
        function updateCloneMovement(clone) {
            if (!clone.parentBoss || !enemies.includes(clone.parentBoss)) {
                clone.hp = 0;
                createExplosion(clone.x + clone.width/2, clone.y + clone.height/2, clone.color, 20);
                return;
            }

            const currentTime = clone.movementTime;
            const centerX = clone.parentBoss.x + clone.parentBoss.width/2;
            const centerY = clone.parentBoss.y + clone.parentBoss.height/2;
            
            // è®¡ç®—åŠ¨æ€è½¨é“åŠå¾„
            const radiusVariation = Math.sin(currentTime * clone.radiusSpeed + clone.radiusPhase) * 50;
            const currentRadius = clone.baseOrbitRadius + radiusVariation;
            
            // éšæœºæ”¹å˜è¿åŠ¨æ–¹å‘
            const now = Date.now();
            if (now - clone.lastDirectionChange > 2000 + Math.random() * 2000) {  // 2-4ç§’éšæœºæ”¹å˜æ–¹å‘
                if (Math.random() < 0.3) {  // 30%çš„æ¦‚ç‡æ”¹å˜æ–¹å‘
                    clone.currentDirection *= -1;
                    clone.lastDirectionChange = now;
                    // åˆ›å»ºæ–¹å‘æ”¹å˜çš„è§†è§‰æ•ˆæœ
                    createExplosion(clone.x + clone.width/2, clone.y + clone.height/2, '#1abc9c', 10);
                }
            }
            
            // è®¡ç®—èºæ—‹è¿åŠ¨
            const spiralOffset = Math.sin(currentTime * 0.5) * 30;
            const angle = currentTime * clone.orbitSpeed * clone.currentDirection + clone.initialAngle;
            
            // åŸºç¡€ä½ç½®è®¡ç®—
            clone.x = centerX + Math.cos(angle) * currentRadius + Math.cos(angle * 2) * spiralOffset - clone.width/2;
            clone.y = centerY + Math.sin(angle) * currentRadius + Math.sin(currentTime * 0.7 + clone.verticalPhase) * 40 - clone.height/2;
            
            // è¾¹ç•Œæ£€æŸ¥å’Œè°ƒæ•´
            clone.x = Math.max(0, Math.min(canvas.width - clone.width, clone.x));
            clone.y = Math.max(0, Math.min(canvas.height/2, clone.y));
            
            // æ›´æ–°æ—¶é—´
            clone.movementTime += 0.016;
            
            // éšæœºå°„å‡»
            if (Math.random() < clone.shootRate) {
                const currentTime = Date.now();
                if (currentTime - clone.lastShot > 1000) {
                    createEnemyBullet(clone);
                    clone.lastShot = currentTime;
                }
            }
        }

        // æ·»åŠ åˆ†è£‚ä½“åˆ›å»ºå‡½æ•°
        function createSplitEnemy(parent, direction) {
            const splitSize = parent.width * 0.8; // åˆ†è£‚ä½“å¤§å°ä¸ºçˆ¶ä½“çš„80%
            const splitSpeed = parent.speed * 1.2; // åˆ†è£‚ä½“é€Ÿåº¦æ¯”çˆ¶ä½“å¿«20%
            
            // æ ¹æ®æ–¹å‘å†³å®šåˆå§‹ä½ç½®
            const offsetX = direction === 'left' ? -splitSize : parent.width;
            
            const splitEnemy = {
                x: parent.x + offsetX,
                y: parent.y,
                width: splitSize,
                height: splitSize,
                speed: splitSpeed,
                color: '#2ecc71', // ä½¿ç”¨ä¸åŒçš„é¢œè‰²ä»¥åŒºåˆ†
                shape: parent.shape,
                hp: Math.ceil(parent.maxHp * 0.4),
                maxHp: Math.ceil(parent.maxHp * 0.4),
                score: Math.floor(parent.score * 0.5),
                dropRate: 0, // åˆ†è£‚ä½“ä¸æ‰è½é“å…·
                shootRate: parent.shootRate * 0.7,
                bulletSize: parent.bulletSize * 0.8,
                special: null, // åˆ†è£‚ä½“ä¸èƒ½å†åˆ†è£‚
                movementPattern: "split",
                movementTime: 0,
                lastShot: 0,
                isSplit: true,
                parentType: parent.type,
                resistance: parent.resistance,
                direction: direction,
                initialX: parent.x + offsetX,
                splitAngle: direction === 'left' ? -Math.PI/6 : Math.PI/6 // åˆå§‹è¿åŠ¨è§’åº¦
            };
            
            splitEnemies.push(splitEnemy);
            console.log(`åˆ†è£‚ä½“å·²åˆ›å»º - ä½ç½®: (${splitEnemy.x.toFixed(2)}, ${splitEnemy.y.toFixed(2)}), å¤§å°: ${splitSize}`);
            
            // åˆ›å»ºåˆ†è£‚æ•ˆæœ
            createExplosion(splitEnemy.x + splitEnemy.width/2, splitEnemy.y + splitEnemy.height/2, splitEnemy.color, 20);
        }

        // æ·»åŠ åˆ†è£‚ä½“ç§»åŠ¨æ›´æ–°å‡½æ•°
        function updateSplitMovement(split) {
            // åˆ†è£‚ä½“çš„ç‰¹æ®Šç§»åŠ¨æ¨¡å¼
            const currentTime = split.movementTime;
            
            // åŸºç¡€å‘ä¸‹ç§»åŠ¨
            split.y += split.speed * 0.8;
            
            // æ ¹æ®æ–¹å‘æ·»åŠ æ°´å¹³ç§»åŠ¨
            const horizontalSpeed = split.speed * 0.6;
            if (split.direction === 'left') {
                split.x = split.initialX + Math.sin(currentTime * 1.5) * 50 - horizontalSpeed;
            } else {
                split.x = split.initialX + Math.sin(currentTime * 1.5) * 50 + horizontalSpeed;
            }
            
            // è¾¹ç•Œæ£€æŸ¥
            split.x = Math.max(0, Math.min(canvas.width - split.width, split.x));
            
            // æ›´æ–°æ—¶é—´
            split.movementTime += 0.016;
        }

        // åœ¨æ¸¸æˆä¸»å¾ªç¯ä¸­æ·»åŠ åˆ†è£‚ä½“æ›´æ–°
        function gameLoop() {
            if (!player.isAlive) {
                gameStarted = false;
                return;
            }
            
            drawBackground();
            
            updatePlayer();
            updateBullets();
            updateLasers();
            updateEnemies();
            
            // æ›´æ–°å’Œç»˜åˆ¶å…‹éš†ä½“
            clones = clones.filter(clone => {
                if (clone.hp <= 0) return false;
                updateCloneMovement(clone);
                drawEnemy(clone);
                return handleEnemyCollisions(clone);
            });
            
            // æ›´æ–°å’Œç»˜åˆ¶åˆ†è£‚ä½“
            splitEnemies = splitEnemies.filter(split => {
                if (split.hp <= 0) return false;
                updateSplitMovement(split);
                drawEnemy(split);
                return handleEnemyCollisions(split);
            });
            
            updatePowerUps();
            updateParticles();
            
            requestAnimationFrame(gameLoop);
        }

        // æ·»åŠ é€šç”¨çš„æ•Œäººç¢°æ’å¤„ç†å‡½æ•°
        function handleEnemyCollisions(enemy) {
            // æ£€æŸ¥å­å¼¹ç¢°æ’
            bullets.forEach((bullet, index) => {
                if (checkCollision(bullet, enemy)) {
                    const damage = bullet.damage * (1 - enemy.resistance);
                    enemy.hp -= damage;
                    bullets.splice(index, 1);
                    
                    if (enemy.hp <= 0) {
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.color, 20);
                        score += enemy.score;
                        scoreElement.textContent = `å¾—åˆ†: ${score}`;
                    }
                }
            });
            
            // æ£€æŸ¥ä¸ç©å®¶çš„ç¢°æ’
            if (checkCollision(enemy, player) && !player.invincible) {
                playerDamage();
            }
            
            return enemy.hp > 0 && enemy.y < canvas.height + 100;
        }

        // æ·»åŠ ç”»å¸ƒç¼©æ”¾å¤„ç†
        function resizeCanvas() {
            const maxWidth = Math.min(480, window.innerWidth - 20);
            const scale = maxWidth / 480;
            canvas.style.width = maxWidth + 'px';
            canvas.style.height = (700 * scale) + 'px';
        }

        // ç›‘å¬çª—å£å¤§å°å˜åŒ–
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>